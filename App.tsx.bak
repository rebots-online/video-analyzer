import { useState, useRef, useEffect, useCallback } from 'react';
import { Theme, applyTheme } from './src/themes';

interface Timestamp {
  time: number;
  text: string;
  objects?: string[];
}

interface VideoAnalysis {
  summary: string;
  timestamps: Timestamp[];
}

// Format seconds to MM:SS
export const formatTime = (seconds: number): string => {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
};

const App = () => {
  const [videoUrl, setVideoUrl] = useState<string | null>(null);
  const [analysis, setAnalysis] = useState<VideoAnalysis | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [theme, setTheme] = useState<Theme>('dark-skeuo');
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Apply theme on component mount and when theme changes
  useEffect(() => {
    applyTheme(theme);
  }, [theme]);

  const handleFileSelect = useCallback(async (file: File) => {
    try {
      setLoading(true);
      setError(null);
      
      // Create a URL for the video preview
      const url = URL.createObjectURL(file);
      setVideoUrl(url);
      
      // Simulate API call for analysis
      const mockAnalysis: VideoAnalysis = {
        summary: 'This is a mock analysis of the video content. In a real application, this would be generated by an AI model.',
        timestamps: [
          { time: 0, text: 'Introduction to the video content' },
          { time: 30, text: 'Main topic discussion begins' },
          { time: 90, text: 'Key insights and analysis' },
          { time: 150, text: 'Conclusion and summary' },
        ],
      };
      
      // Simulate API delay
      await new Promise(resolve => setTimeout(resolve, 1500));
      setAnalysis(mockAnalysis);
      
    } catch (err) {
      console.error('Error processing video:', err);
      setError('Failed to process the video. Please try again.');
    } finally {
      setLoading(false);
    }
  }, []);

export default function App() {
  // State management
  const [videoUrl, setVideoUrl] = useState<string | null>(null);
  const [analysis, setAnalysis] = useState<VideoAnalysis | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [theme] = useState<Theme>('dark-skeuo');
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  // Apply theme on mount and when theme changes
  useEffect(() => {
    applyTheme(theme);
  }, [theme]);

  const handleFileSelect = useCallback(async (file: File) => {
    setLoading(true);
    setError(null);
    setAnalysis(null);
    
    try {
      // Create a URL for the video preview
      const url = URL.createObjectURL(file);
      setVideoUrl(url);
      
      // In a real app, you would send this to your API
      // const formData = new FormData();
      // formData.append('video', file);
      // const response = await fetch('/api/analyze', { method: 'POST', body: formData });
      // const data = await response.json();
      
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Mock analysis data
      setAnalysis({
        summary: 'Video analysis completed successfully. This is a sample analysis that would contain insights about your video content.',
        timestamps: [
          { time: 0, text: 'Introduction to the video content' },
          { time: 30, text: 'Main topic discussion begins' },
          { time: 90, text: 'Key points and examples' },
          { time: 150, text: 'Conclusion and summary' }
        ]
      });
    } catch (err) {
      setError('Failed to analyze video. Please try again.');
      console.error('Analysis error:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  const handleDrop = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('video/')) {
      handleFileSelect(file);
    }
  }, [handleFileSelect]);

  const handleDragOver = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
  };

  const handleTimestampClick = (time: number) => {
    // In a real app, this would seek the video to the specified time
    console.log(`Seek to ${time} seconds`);
  };

  const renderUploadArea = () => (
    <div 
      className="upload-area"
      onDrop={handleDrop}
      onDragOver={handleDragOver}
    >
      <input
        type="file"
        ref={fileInputRef}
        onChange={handleFileInputChange}
        accept="video/*"
        style={{ display: 'none' }}
      />
      <button 
        className="upload-button"
        onClick={() => fileInputRef.current?.click()}
        disabled={loading}
      >
        {loading ? 'Processing...' : 'Select Video File'}
      </button>
      <p className="upload-hint">or drag and drop a video file here</p>
    </div>
  );

  const renderAnalysis = () => (
    <div className="analysis-container">
      <div className="video-preview">
        {videoUrl && (
          <video 
            src={videoUrl} 
            controls 
            className="video-player"
          />
        )}
      </div>
      <div className="analysis-results">
        <h2>Analysis Results</h2>
        {analysis?.summary && (
          <div className="summary">
            <h3>Summary</h3>
            <p>{analysis.summary}</p>
          </div>
        )}
        {analysis?.timestamps && analysis.timestamps.length > 0 && (
          <div className="timestamps">
            <h3>Key Moments</h3>
            <ul>
              {analysis.timestamps.map((item, index) => (
                <li 
                  key={index} 
                  className="timestamp-item"
                  onClick={() => handleTimestampClick(item.time)}
                >
                  <span className="time">{formatTime(item.time)}</span>
                  <span className="text">{item.text}</span>
                </li>
              ))}
            </ul>
          </div>
        )}
      </div>
    </div>
  );

  return (
    <div className="app">
      <header className="app-header">
        <h1>Video Analyzer</h1>
        <p>Upload a video to analyze its content and generate timestamps</p>
      </header>
      
      <main className="app-content">
        {!videoUrl ? renderUploadArea() : renderAnalysis()}
        
        {error && (
          <div className="error-message">
            <p>{error}</p>
            <button onClick={() => setError(null)}>Dismiss</button>
          </div>
        )}
      </main>
      
      <footer className="app-footer">
        <p>Video Analyzer &copy; {new Date().getFullYear()}</p>
      </footer>
    </div>
  );

  const setTimecodes = ({timecodes}) =>
    setTimecodeList(
      timecodes.map((t) => ({...t, text: t.text.replaceAll("\\'", "'")})),
    );

  const onModeSelect = async (mode) => {
    setActiveMode(mode);
    setIsLoading(true);
    setChartLabel(chartPrompt);

    const resp = await generateContent(
      isCustomMode
        ? modes[mode].prompt(customPrompt)
        : isChartMode
          ? modes[mode].prompt(
              isCustomChartMode ? chartPrompt : modes[mode].subModes[chartMode],
            )
          : modes[mode].prompt,
      functions({
        set_timecodes: setTimecodes,
        set_timecodes_with_objects: setTimecodes,
        set_timecodes_with_numeric_values: ({timecodes}) =>
          setTimecodeList(timecodes),
      }),
      file,
    );

    const call = resp.functionCalls?.[0];

    if (call) {
      ({
        set_timecodes: setTimecodes,
        set_timecodes_with_objects: setTimecodes,
        set_timecodes_with_numeric_values: ({timecodes}) =>
          setTimecodeList(timecodes),
      })[call.name](call.args);
    }

    setIsLoading(false);
    scrollRef.current.scrollTo({top: 0});
  };

  const uploadVideo = async (e) => {
    e.preventDefault();
    setIsLoadingVideo(true);
    setVidUrl(URL.createObjectURL(e.dataTransfer.files[0]));

    const file = e.dataTransfer.files[0];

    try {
      const res = await uploadFile(file);
      setFile(res);
      setIsLoadingVideo(false);
    } catch (e) {
      setVideoError(true);
    }
  };

  const renderContent = (): ReactNode => {
    if (loading) {
      return <div className="loading">Analyzing video...</div>;
    }
    
    if (error) {
      return <div className="error">{error}</div>;
    }
    
    if (!analysis) {
      return (
        <UploadArea 
          onFileSelect={handleFileSelect} 
          isLoading={loading} 
        />
      );
    }
    
    return (
      <div className="analysis-container">
        <div className="video-container">
          {videoUrl && (
            <video 
              src={videoUrl} 
              controls 
              className="video-player"
            />
          )}
        </div>
        <div className="analysis-results">
          <h2>Analysis Results</h2>
          <p>{analysis.summary}</p>
          
          {analysis.timestamps && analysis.timestamps.length > 0 && (
            <div className="timestamps">
              <h3>Key Moments</h3>
                    <tr
                      key={i}
                      role="button"
                      onClick={() => setRequestedTimecode(timeToSecs(time))}>
                      <td>
                        <time>{time}</time>
                      </td>
                      <td>{text}</td>
                      <td>{objects.join(', ')}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            ) : activeMode === 'Chart' ? (
              <Chart
                data={timecodeList}
                yLabel={chartLabel}
                jumpToTimecode={setRequestedTimecode}
              />
            ) : modes[activeMode].isList ? (
              <ul>
                {timecodeList.map(({time, text}, i) => (
                  <li key={i} className="outputItem">
                    <button
                      onClick={() => setRequestedTimecode(timeToSecs(time))}>
                      <time>{time}</time>
                      <p className="text">{text}</p>
                    </button>
                  </li>
                ))}
              </ul>
            ) : (
              timecodeList.map(({time, text}, i) => (
                <>
                  <span
                    key={i}
                    className="sentence"
                    role="button"
                    onClick={() => setRequestedTimecode(timeToSecs(time))}>
                    <time>{time}</time>
                    <span>{text}</span>
                  </span>{' '}
                </>
              ))
            )
          ) : null}
        </div>
      </div>
    );
  };

  return (
    <main
      className={theme}
      onDrop={uploadVideo}
      onDragOver={(e) => e.preventDefault()}
      onDragEnter={() => {}}
      onDragLeave={() => {}}>
      <section className="top">
        {vidUrl && !isLoadingVideo && (
          <>
            <div className={c('modeSelector', {hide: !showSidebar})}>
              {hasSubMode ? (
                <>
                  <div>
                    {isCustomMode ? (
                      <>
                        <h2>Custom prompt:</h2>
                        <textarea
                          placeholder="Type a custom prompt..."
                          value={customPrompt}
                          onChange={(e) => setCustomPrompt(e.target.value)}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                              e.preventDefault();
                              onModeSelect(selectedMode);
                            }
                          }}
                          rows="5"
                        />
                      </>
                    ) : (
                      <>
                        <h2>Chart this video by:</h2>

                        <div className="modeList">
                          {chartModes.map((mode) => (
                            <button
                              key={mode}
                              className={c('button', {
                                active: mode === chartMode,
                              })}
                              onClick={() => setChartMode(mode)}>
                              {mode}
                            </button>
                          ))}
                        </div>
                        <textarea
                          className={c({active: isCustomChartMode})}
                          placeholder="Or type a custom prompt..."
                          value={chartPrompt}
                          onChange={(e) => setChartPrompt(e.target.value)}
                          onKeyDown={(e) => {
                            if (e.key === 'Enter') {
                              e.preventDefault();
                              onModeSelect(selectedMode);
                            }
                          }}
                          onFocus={() => setChartMode('Custom')}
                          rows="2"
                        />
                      </>
                    )}
                    <button
                      className="button generateButton"
                      onClick={() => onModeSelect(selectedMode)}
                      disabled={
                        (isCustomMode && !customPrompt.trim()) ||
                        (isChartMode &&
                          isCustomChartMode &&
                          !chartPrompt.trim())
                      }>
                      ▶️ Generate
                    </button>
                  </div>
                  <div className="backButton">
                    <button
                      onClick={() => setSelectedMode(Object.keys(modes)[0])}>
                      <span className="icon">chevron_left</span>
                      Back
                    </button>
                  </div>
                </>
              ) : (
                <>
                  <div>
                    <h2>Explore this video via:</h2>
                    <div className="modeList">
                      {Object.entries(modes).map(([mode, {emoji}]) => (
                        <button
                          key={mode}
                          className={c('button', {
                            active: mode === selectedMode,
                          })}
                          onClick={() => setSelectedMode(mode)}>
                          <span className="emoji">{emoji}</span> {mode}
                        </button>
                      ))}
                    </div>
                  </div>
                  <div>
                    <button
                      className="button generateButton"
                      onClick={() => onModeSelect(selectedMode)}>
                      ▶️ Generate
                    </button>
                  </div>
                </>
              )}
            </div>
            <button
              className="collapseButton"
              onClick={() => setShowSidebar(!showSidebar)}>
              <span className="icon">
                {showSidebar ? 'chevron_left' : 'chevron_right'}
              </span>
            </button>
          </>
        )}

        <VideoPlayer
          url={vidUrl}
          requestedTimecode={requestedTimecode}
          timecodeList={timecodeList}
          jumpToTimecode={setRequestedTimecode}
          isLoadingVideo={isLoadingVideo}
          videoError={videoError}
        />
      </section>

      <div className={c('tools', {inactive: !vidUrl})}>
        <section
          className={c('output', {['mode' + activeMode]: activeMode})}
          ref={scrollRef}>
          {isLoading ? (
            <div className="loading">
              Waiting for model<span>...</span>
            </div>
          ) : timecodeList ? (
            activeMode === 'Table' ? (
              <table>
                <thead>
                  <tr>
                    <th>Time</th>
                    <th>Description</th>
                    <th>Objects</th>
                  </tr>
                </thead>
                <tbody>
                  {timecodeList.map(({time, text, objects}, i) => (
                    <tr
                      key={i}
                      role="button"
                      onClick={() => setRequestedTimecode(timeToSecs(time))}>
                      <td>
                        <time>{time}</time>
                      </td>
                      <td>{text}</td>
                      <td>{objects.join(', ')}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            ) : activeMode === 'Chart' ? (
              <Chart
                data={timecodeList}
                yLabel={chartLabel}
                jumpToTimecode={setRequestedTimecode}
              />
            ) : modes[activeMode].isList ? (
              <ul>
                {timecodeList.map(({time, text}, i) => (
                  <li key={i} className="outputItem">
                    <button
                      onClick={() => setRequestedTimecode(timeToSecs(time))}>
                      <time>{time}</time>
                      <p className="text">{text}</p>
                    </button>
                  </li>
                ))}
              </ul>
            ) : (
              timecodeList.map(({time, text}, i) => (
                <>
                  <span
                    key={i}
                    className="sentence"
                    role="button"
                    onClick={() => setRequestedTimecode(timeToSecs(time))}>
                    <time>{time}</time>
                    <span>{text}</span>
                  </span>{' '}
                </>
              ))
            )
          ) : null}
        </section>
      </div>
    </main>
  );
}
